#include <stdio.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "driver/gpio.h"
#include "driver/periph_ctrl.h"
#include "soc/timer_group_struct.h"
#include "driver/gptimer.h"
#define TIMER_DIVIDER 40 // 80MHz / 80 = 1MHz
#define TIMER_SCALE (TIMER_BASE_CLK / TIMER_DIVIDER) // Timer scale to microseconds
#define OUTPUT_DEMOD_IN_DIAG GPIO_NUM_1  // GPIO pin for DEMOD_IN_DIAG
#define OUTPUT_SIG_IN_DIAG GPIO_NUM_2  // GPIO pin for Preamble_indicator
#define OUTPUT_Preamble_indicator GPIO_NUM_3  // GPIO pin for Preamble_indicator
#define SEQUENCE_LENGTH   41        // Length of bit sequence
// Data to send (example)
static const uint8_t sequence0[SEQUENCE_LENGTH] = {1,0,1,0,1,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0}; //{0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0};
static const uint8_t sequence1[SEQUENCE_LENGTH] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
static const uint8_t sequence2[SEQUENCE_LENGTH] = {1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
int sequence_end = 0;
gptimer_handle_t gptimer = NULL;
// Function prototype for the timer ISR
static bool IRAM_ATTR onTimer(gptimer_handle_t timer, const gptimer_alarm_event_data_t *edata, void *user_data);
// Configure GPTIMER
void configureGPTimer() {
     gptimer_config_t timer_config = {
     .clk_src = GPTIMER_CLK_SRC_DEFAULT,
     .direction = GPTIMER_COUNT_UP,
     .resolution_hz = 2000000, // This entry corresponds to the timer frequency.
     };
     gptimer_event_callbacks_t cbs = {
     .on_alarm = onTimer, // register user callback
     };
     ESP_ERROR_CHECK(gptimer_new_timer(&timer_config, &gptimer));
     ESP_ERROR_CHECK(gptimer_register_event_callbacks(gptimer, &cbs, nullptr ));
     ESP_ERROR_CHECK(gptimer_enable(gptimer));
     gptimer_alarm_config_t alarm_config = {
          .alarm_count = 25, // period = 12.5us @resolution 2MHz
          .reload_count = 0, // counter will reload with 0 on alarm event
     };
     alarm_config.flags.auto_reload_on_alarm = true;
     ESP_ERROR_CHECK(gptimer_set_alarm_action(gptimer, &alarm_config));
     ESP_ERROR_CHECK(gptimer_start(gptimer));
}
// Timer ISR
static bool IRAM_ATTR onTimer(gptimer_handle_t timer, const gptimer_alarm_event_data_t *edata, void *user_data)
{
    // Send the next bit
    static uint8_t index = 0;
    gpio_set_level(OUTPUT_DEMOD_IN_DIAG, sequence0[index]);
	gpio_set_level(OUTPUT_SIG_IN_DIAG, sequence1[index]);
	gpio_set_level(OUTPUT_Preamble_indicator, sequence2[index]);
    // Increment index and wrap around if necessary
    index = (index + 1) % SEQUENCE_LENGTH;
    if(index == 0 ){
        sequence_end = 1;
    }
    else{
        sequence_end = 0;
    }
    return 0;
}
extern "C" void app_main(void) {
    // Configure data pin
     gpio_config_t io_conf;
     io_conf.intr_type = GPIO_INTR_DISABLE;
     io_conf.mode = GPIO_MODE_OUTPUT;
     io_conf.pin_bit_mask = (1ULL << OUTPUT_PIN);
     io_conf.pull_down_en = GPIO_PULLDOWN_DISABLE;
     io_conf.pull_up_en = GPIO_PULLUP_DISABLE;
     gpio_config(&io_conf);
     // Call the function to configure GPTimer
     configureGPTimer();
     while(1){
          if (sequence_end == 1){
               ESP_ERROR_CHECK(gptimer_stop(gptimer));
               ESP_ERROR_CHECK(gptimer_disable(gptimer));
               ESP_ERROR_CHECK(gptimer_del_timer(gptimer));
               break;
          }
     }
}
